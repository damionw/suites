#! /usr/bin/env bash

scriptfile="${BASH_SOURCE[0]}"

headers=(
    "HTTP/1.1 200 OK"
)

URL_REGEXES=()

reactor::depends() {
   :
}

reactor::run() {
    local _task="${1}"
    local _shell="$(which bash)"
    local _port="$(http::listen_port)"

    logging::info "Started webserver on port ${_port}"

    exec ncat -l ${_port} -k --sh-exec "'${_shell}' -c '. $(script::file); http::handle_request'"
}

#===================================================================================
#                             Script Info
#===================================================================================
script::file() {
    echo "${scriptfile}"
}

#===================================================================================
#                              Response Functions
#===================================================================================
response::set_status() {
    local _code="${1}"
    local _version="${2}"

    local HTTP_CODE=(
        [200]="OK"
        [400]="Bad Request"
        [403]="Forbidden"
        [404]="Not Found"
        [405]="Method Not Allowed"
        [500]="Internal Server Error"
    )

    headers[0]="${_version} ${_code} ${HTTP_CODE[${_code}]}"
}

response::add_header() {
    headers[${#headers[@]}]="$*"
}

response::get_headers() {
    local _index

    for ((_index=0; _index < ${#headers[@]}; ++_index)) {
        echo "${headers[${_index}]}"
    }
}

response::send() {
    # Content comes in via stdin
    {
        response::get_headers
        echo
        cat
    } | tee /tmp/dkwtest.txt | unix2dos
}

#===================================================================================
#                                Headers
#===================================================================================
header::server_type() {
    response::add_header "Server: ${HTTP_SCRIPT}"
}

header::text_html() {
    header::content_type text/html
}

header::text_plain() {
    header::content_type "text/plain; charset=utf-8"
}

header::application_json() {
    header::content_type application/json
}

header::application_javascript() {
    header::content_type application/javascript
}

header::text_css() {
    header::content_type text/css
}

header::content_type() {
    response::add_header "Content-Type: ${1}"
}

header::content_length() {
    test "${1:-0}" -gt 0 && response::add_header "Content-Length: ${1}"
}

#===================================================================================
#                                TCP/IP
#===================================================================================
tcp::available_ports() {
    start_port=${1:-9000}
    protocol=${2:-tcp}

    address_family=$(echo ${protocol}4 | sed -e 's/^[^0-9]*//g' | dd bs=1 count=1 2>/dev/null)
    protocol=$(echo ${protocol} | sed -e 's/[0-9].*$//g')

    netstat -ln --${protocol} -${address_family} |
    awk '{print $4;}' |
    awk -F: '{print $2;}' |
    sed -e '/^[ ]*$/d' |
    sort -n |
    awk '{
        for (; i < $1; ++i)
        {
            print i;
        }

        if (i == $1)
        {
            ++i;
        }
    }' i=${start_port}
}

tcp::unused_port() {
    tcp::available_ports $* | head -1
}

#===================================================================================
#                                URL Matching
#===================================================================================
url::add_handler() {
    local _regex="${1}"
    local _methods="${2}" # GET,POST
    local _handler="${3}" # http::handler...

    URL_REGEXES["${#URL_REGEXES[@]}"]="_regex='${_regex}'; _methods='${_methods}'; _handler='${_handler}'"
}

url::match_handler() {
    local _method="${1}"
    local _request="${2}"

    local _regex
    local _methods
    local _handler
    local _index

    for ((_index=0; _index < ${#URL_REGEXES[@]}; ++_index)) {
        eval "${URL_REGEXES[${_index}]}"

        if [ -z "$(echo "${_request}" | awk "/${_regex}/"'{print $1;}')" ]
        then
            :
        elif ! (echo "${_methods}" | awk -F, '{for (i=1; i <= NF; ++i) {print $i;}}' | grep -q '^'"${_method}"'$')
        then
            :
        else
            echo "${_handler}"
            return 0
        fi
    }

    return 255
}

#===================================================================================
#                                HTTP Handlers
#===================================================================================
logging::info() {
    local _retval=$?
    echo -e "$(date '+%Y-%m-%d %H:%M:%S'): $*" >&2
    return $_retval
}

http::listen_port() {
    tcp::unused_port
}

http::400_error() {
    response::set_status 400 "HTTP/1.1"
    header::server_type
    response::send
}

http::404_error() {
    response::set_status 404 "HTTP/1.1"
    header::server_type
    response::send
}

http::response_html() {
    response::set_status 200 "HTTP/1.1"
    header::server_type
    header::text_html
    response::send
}

http::response_json() {
    response::set_status 200 "HTTP/1.1"
    header::server_type
    header::application_json
    response::send
}

http::response_css() {
    response::set_status 200 "HTTP/1.1"
    header::server_type
    header::text_css
    response::send
}

http::response_javascript() {
    response::set_status 200 "HTTP/1.1"
    header::server_type
    header::application_javascript
    response::send
}

http::response_plain() {
    response::set_status 200 "HTTP/1.1"
    header::server_type
    header::text_plain
    response::send
}

http::response_index() {
    http::response_file GET index.html "${3}"
}

http::response_file() {
    local _method="${1}"
    local _request="${2}"
    local _headers="${3}"
    local _filename="$(dirname "$(script::file)")/static/$(basename "${_request}")"
    local _extension="$(echo "${_filename}" | awk -F. '{print $NF;}' | tr '[A-Z]' '[a-z]')"

    if [ ! -f "${_filename}" ]
    then
        http::404_error
        return 255
    fi

    case "${_extension}" in
        html)
            http::response_html
            ;;

        js)
            http::response_javascript
            ;;

        json)
            http::response_json
            ;;

        css)
            http::response_css
            ;;

        *)
            response::set_status 200 "HTTP/1.1"
            header::server_type
            header::content_type "$(file -b --mime-type "${_filename}")"
            header::content_length "$(stat -c'%s' "${_filename}")"
            response::send
            ;;
    esac < "${_filename}"
}

http::response_suite_status() {
    "${SUITE_SCRIPT}" --suite="$(dirname "$(script::file)")" --status | http::response_json
}

http::handle_request() {
    local _method
    local _request
    local _version
    local _handler
    local _row

    if ! read _method _request _version
    then
        http::400_error
        return 255
    fi

    logging::info "${_method}" "${_request}"

    # Fetch incoming headers
    local _headers="$(
        while read -t 0.01 _row
        do
            echo "${_row}"
        done | sed -e 's/\r//g' -e '/^[ ]*$/d'
    )"

    url::add_handler '^\/$' GET http::response_index
    url::add_handler '^\/index.html$' GET http::response_index
    url::add_handler '^\/api\/status[\/]*$' GET http::response_suite_status
    url::add_handler '^\/static\/.*$' GET http::response_file

    if ! _handler="$(url::match_handler "${_method}" "${_request}")"
    then
        http::404_error
        return 255
    fi

    "${_handler:-"http::404_error"}" "${_method}" "${_request}" "${_headers}"
}
